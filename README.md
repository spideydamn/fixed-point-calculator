# Fixed Point Calculator

## Описание
Программа для выполнения арифметических операций над числами с фиксированной точкой с поддержкой различных режимов округления. Реализована на C++20 с использованием модульной арифметики и обработки чисел в формате дополнения до двух.

## Особенности
- Поддержка основных арифметических операций: сложение, вычитание, умножение, деление
- Четыре режима округления:
  - К нулю (0)
  - К ближайшему чётному (1)
  - К +∞ (2)
  - К -∞ (3)
- Поддержка отрицательных чисел
- Точность вывода: 3 знака после запятой

## Использование
### Сборка
```bash
g++ -std=c++20 main.cpp -o fixed_point_calculator
```

### Запуск
Для выполнения операций:
```bash
./fixed_point_calculator <формат> <округление> <число1> <операция> <число2>
```

Для простого вывода числа:
```bash
./fixed_point_calculator <формат> <округление> <число>
```

### Параметры
- `<формат>`: строка вида "A.B", где:
  - A - количество бит целой части (≥1)
  - B - количество бит дробной части
  - A + B ≤ 32
- `<округление>`: цифра 0-3, соответствующая режиму округления
- `<числа>`: в шестнадцатеричном формате с префиксом "0x"
- `<операция>`: один из символов +, -, *, /

## Примеры
```bash
# Сложение
./fixed_point_calculator 8.24 1 0x1000000 + 0x2000000

# Вывод числа
./fixed_point_calculator 8.24 1 0x1000000
```

## Реализация
### Хранение чисел
Числа хранятся в 64-битных беззнаковых целых (`uint64_t`) с использованием арифметики дополнения до двух для представления отрицательных значений.

### Операции
- **Сложение/вычитание**: выполняются напрямую с помощью встроенных арифметических операций
- **Умножение/деление**: используют дополнительные биты для промежуточных вычислений с последующим округлением

### Округление
Реализованы четыре режима округления:
1. **К нулю**: отбрасывание дробной части
2. **К ближайшему чётному**: 
   - Если отбрасываемая часть > 0.5 - округление вверх
   - Если < 0.5 - вниз
   - Если = 0.5 - к ближайшему чётному
3. **К +∞**: округление вверх для положительных, вниз для отрицательных
4. **К -∞**: округление вниз для положительных, вверх для отрицательных

## Автор
Яворский Даниил Евгеньевич, группа M3101, 2024 год

## Детали реализации

### Вспомогательные функции для работы с битами

Сначала ряд вспомогательных функций для работы с битовыми представлениями чисел:

- `bool CheckBit(uint64_t number, uint8_t n)` - Функция, возвращающая `true`, если в `number` на `n`-ом месте `единица`, считая с младших битов, и `false`, если `нуль`.
- `uint64_t ClearBit(uint64_t number, uint64_t n)` - Функция, возвращающая результат выключения `n`-ого бита числа `number`, считая с младших битов.
- `uint64_t LeaveNLowBits(uint64_t number, uint8_t n)` - Выключает `(64 - n)` старших битов числа `number`, возвращая его измененным (т.е. `n` младших битов).
- `uint64_t ClearNLowBits(uint64_t number, uint8_t n)` - Сдвигает вправо на `n` битов число `number`, возвращая его измененным.
- `uint64_t Pow(uint64_t base, uint64_t degree)` - Функция, возвращающая результат возведения `base` в степень `degree`. Нужна для возведения 10₁₀ в степень.

Можно было обойтись без функции `Pow`, если не делать точность вычисления как `const uint8_t kPrecision = 3`, а вместо `Pow(10, kPrecision)` писать просто `1000`.

### Функция Parse

Функция `void Parse(int argc, char **argv)`, в которую передаются `argc` и `argv`. Она парсит аргументы и занимается последующим вычислением.

После проверки корректности количества передаваемых аргументов в ней используются функции:

- `std::pair<uint8_t, uint8_t> CheckFormat(char* arg)` - Проверяет формат чисел с **fixed** точкой, возвращает пару чисел: **размер** целой части и дробной:

| формат | пояснение |
|--------|-----------|
| *A.B*  | числа с фиксированной точкой, где *A* и *B* – неотрицательные целые числа, обозначающие целую и дробную часть. Гарантируется, что *A+B<=32* и *A>=1*. |

- `Type CheckRoundingValue(char* arg)` - Проверяет на корректность и возвращает **тип округления**:

| тип округления | пояснение |
|----------------|-----------|
| 0              | к нулю (toward_zero) |
| 1              | к ближайшему чётному (nearest_even) |
| 2              | к +∞ (toward_infinity) |
| 3              | к -∞ (toward_neg_infinity) |

- `Operation CheckOperation(char* arg)` - Проверяет на корректность и возвращает **операцию**, которая производится между числами если таковая имеется.
- `uint64_t CheckHexadecimalNumber(char* arg)` - Проверяет **числа в шестнадцатеричной системе счисления** в форме с префиксом '0x' на корректность ввода, переводит их в десятеричную систему счисления и возвращает результат.

После проверки и записи в более удобный и понятный вид всех аргументов, если нам передано одно число, то записываем его в результат, иначе если нам передается два числа и операция, то считаем результат функцией:

- `uint64_t Calculate(std::pair<uint8_t, uint8_t>& format, uint64_t first_number, Operation operation, uint64_t second_number, Type type)` - Считает **сумму/разность/произведение/частное** передаваемых чисел в соответствии с форматом.

В свою очередь разделяется на 4 соответствующих разным операциям функции:

- `uint64_t Add(uint64_t first_number, uint64_t second_number)` - Считает **сумму** элементов просто побитово складывая два числа.
- `uint64_t Subtract(uint64_t first_number, uint64_t second_number)` - Считает **разность** элементов просто побитово вычитая из первого числа второе.
- `uint64_t Multiply(std::pair<uint8_t, uint8_t>& format, uint64_t first_number, uint64_t second_number, Type type)` - **Умножает** два числа следующим образом:

  1. Берёт оба числа по модулю:
      - Проверяет, отрицательное ли каждое функцией `CheckBit(number, format.first + format.second - 1)`.
      - Если оно отрицательное, то находит модуль числа, просто взяв число в беззнаковой форме со знаком минус. Получим число которого не хватает до 2₁₀^64. Если удалить лишние старшие биты, что делается в дальнейшем, то получим число, которого не хватает до 2^(размер целой части + размер дробной части).

  2. Если изначально знаки чисел были разные, то возвращает отрицательное произведение с округлением лишних младших разрядов размера дробной части, так как при умножении размер дробной части увеличивается вдвое.

  3. Иначе возвращает произведение с округлением разрядов лишних младших разрядов.

- `uint64_t Divide(std::pair<uint8_t, uint8_t>& format, uint64_t first_number, uint64_t second_number, Type type)` - **Делит** первое число на второе следующим образом:

  1. Берёт оба числа по модулю, аналогично умножению.
  2. Побитово сдвигает первое число максимально влево в uint64_t для максимальной точности.
  3. Если изначально знаки чисел были разные, то возвращает отрицательное частное c округлением лишних младших разрядов.
  4. Иначе возвращает частное c округлением лишних младших разрядов.

При этом не забываем убрать лишние старшие разряды при вводе чисел функцией `LeaveNLowBits(CheckHexadecimalNumber(...), format.first + format.second)`.

### Обработка результата

После вычисления результата удаляем лишние биты с помощью `LeaveNLowBits(result, format.first + format.second)`.

Далее делим число на две части: целую, функцией `ClearNLowBits(result, format.second)`, и дробную, функцией `LeaveNLowBits(result, format.second)`.

Затем проверяется отрицателен ли результат функцией `CheckBit(result, format.first + format.second - 1)`, которая проверяет, горит ли бит отвечающий за знак в форме дополнения до двух.

Если он отрицателен, то:
1. Подставляем целой части минус и убираем лишние старшие биты.
2. Если дробная часть больше нуля, то:
   - Вычитаем единицу из модуля целой части.
   - Подставляем дробной части минус и убираем лишние старшие биты.

Таким образом, по итогу мы получаем модуль целой части и модуль дробной части. После этого мы применяем функцию `uint64_t Round(uint64_t number, Sign sign, Type type, uint8_t real_part_size)` к дробной части, чтобы округлить младшие разряды числа.

Ей на вход передаётся число, положительный или отрицательный знак, тип округления и размер лишних младших разрядов, которые нужно округлить. Далее эта функция распадается на 3 другие, каждая из которых работает в зависимости от знака и типа округления:

- `uint64_t RoundTowardInfinity(uint64_t number, uint8_t real_part_size)` - Срабатывает при отрицательном знаке и округлении к минус бесконечности, при положительном знаке и округлении к плюс бесконечности. Если у числа часть лишних младших разрядов больше нуля, то возвращает число без лишних младших битов, + 1, иначе возвращает просто число без лишних младших битов.
- `uint64_t RoundTowardNegInfinity(uint64_t number, uint8_t real_part_size)` - Срабатывает при любом знаке и округлении к нулю, отрицательном знаке и округлении к плюс бесконечности, при положительном знаке и округлении к минус бесконечности. Возвращает просто число без младших лишних битов.
- `uint64_t RoundNearestEven(uint64_t number, uint8_t real_part_size)` - Срабатывает при любом знаке и округлении к ближайшему четному. Сравнивает часть лишних битов с 0.5₁₀, то есть с 2^(размер части лишних младших битов - 1). Если она больше, то округление вверх. Если меньше, то округление вниз. Если равно, то если биты которые нужно оставить образуют четное число - округление вниз, если нечётное - округление вверх. В итоге получается четное число в конце. Проверка четности - проверка младшего бита целой части числа. Если он горит - число нечётное, иначе чётное. 0.5₁₀ получается сдвигом 1 на (размер дробной части - 1) влево. При переводе из двоичного числа дробная часть будет таким образом равна 1 * 1/2 = 0.5.

После округления идёт проверка не стала ли дробная часть равна 10₁₀^3. Если стала, то к целой части просто прибавляется единица, а дробная обнуляется, как бы перекидывая разряд. Дополнительная проверка если число положительное и целая часть после прибавления единицы выходит за границы. В таком случае мы просто меняем знак, так как после модулярной арифметики получится это же число, только со знаком минус.

Дальше идет проверка если целая и дробная части равны нулю, то знак должен быть плюс, чтобы не выводило в ответ `-0.000`.

Затем просто осуществляется вывод всего числа отдельно. При этом учитывается, если дробная часть имеет меньше разрядов чем надо вывести, сначала подставляются нули.

Числа у меня при этом все хранятся в `uint64_t` - беззнаковое 64 битное число из библиотеки `<cstdint>`.